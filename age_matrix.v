// File: age_matrix.v
// Generated by MyHDL 0.11
// Date: Sat Oct  5 17:39:52 2019


`define CLOG2(x) \
(x <= 2**1  ) ? 1  : \
(x <= 2**2  ) ? 2  : \
(x <= 2**3  ) ? 3  : \
(x <= 2**4  ) ? 4  : \
(x <= 2**5  ) ? 5  : \
(x <= 2**6  ) ? 6  : \
(x <= 2**7  ) ? 7  : \
(x <= 2**8  ) ? 8  : \
(x <= 2**9  ) ? 9  : \
(x <= 2**10 ) ? 10 : \
(x <= 2**11 ) ? 11 : \
(x <= 2**12 ) ? 12 : \
(x <= 2**13 ) ? 13 : \
(x <= 2**14 ) ? 14 : \
(x <= 2**15 ) ? 15 : \
(x <= 2**16 ) ? 16 : \
(x <= 2**17 ) ? 17 : \
(x <= 2**18 ) ? 18 : \
(x <= 2**19 ) ? 19 : \
(x <= 2**20 ) ? 20 : \
(x <= 2**21 ) ? 21 : \
(x <= 2**22 ) ? 22 : \
(x <= 2**23 ) ? 23 : \
(x <= 2**24 ) ? 24 : \
(x <= 2**25 ) ? 25 : \
-1


module group_match #(
	parameter IN_WIDTH = 16,
	parameter OUT_WIDTH = 4,
) (
	input wire [IN_WIDTH-1:0] in,
	output wire [OUT_WIDTH-1:0] out
);
	
	reg [OUT_WIDTH-1:0] valid;
	integer i;
	always @(*) begin
		valid[i] = |(in[(IN_WIDTH-i*OUT_WIDTH)-1: OUT_WIDTH]);
	end
	
	assign out = valid;
	
endmodule

module onehot_check #(
    parameter WIDTH = 4
) (
    input  wire [WIDTH-1:0] in,
    output wire             out
);

localparam integer ONE = 1;

reg ohot;
integer i;

always @(*) begin
    for(i=0; i<WIDTH; i=i+1) begin
        ohot[i] = (in == (ONE << i)) ? 1'b1 : 1'b0;
    end
end

assign out = | ohot;

endmodule


module onehot2thermal #(
    parameter WIDTH = 32,
    parameter DIRECTION = "LSB"         // priority direction
) (
    input  wire [WIDTH-1:0] in,
    output wire [WIDTH-1:0] out
);


//    Functinonal Truth Table
//    DIRECTION == LSB
//    in         out
//    0 0 0 0    0 0 0 0
//    0 0 0 1    0 0 0 1
//    0 0 1 x    0 0 1 1
//    0 1 x x    0 1 1 1
//    1 x x x    1 1 1 1
//    DIRECTION == MSB
//    in         out
//    0 0 0 0    0 0 0 0
//    1 0 0 0    1 0 0 0
//    X 1 0 0    1 1 0 0
//    X X 1 0    1 1 1 0
//    X X X 1    1 1 1 1

genvar i;

generate 
if (DIRECTION == "LSB") begin: LSB
    for (i=0; i<WIDTH; i=i+1) begin
        assign out[i] = |in[WIDTH-1: i];
    end
end else begin: MSB
    for (i=WIDTH-1; i>=0; i=i-1) begin
        assign out[i]= |in[i: 0];
    end
end
endgenerate

endmodule


module onehot2bin #(
	parameter WIDTH     = 4,
	parameter DIRECTION = "LSB"
) (
	input wire [WIDTH-1:0] ohot,
	output wire [`CLOG2(WIDTH)-1:0] bin
);
	

always @(*) begin
	integer i;

	for (i=0; i<WIDTH; i=i+1) begin
	
	end

end



endmodule



module priority_mask #(

	parameter WIDTH     = 16,
	parameter DIRECTION = "MSB"
	
) (
	input  wire [WIDTH-1:0] in,
	output wire [WIDTH-1:0] out,
	output wire             vld
);

/*  
 * Priority mask. Mask out the first zero, direction 
 */


reg [WIDTH-1:0]    tmp;
reg                valid;


generate
if (DIRECTION == "MSB") begin :MSB
	always @(*) begin
		tmp = 0;
		for(i=WIDTH-1; i>=0; i=i-1) begin
			if (in[i] == 1'b1) begin
				tmp[i] = 1'b1;
				valid =  1'b1;
				break;
			end
		end	
	end
else begin: LSB
	always @(*) begin
		tmp = 0;
		for(i=0; i<WIDTH; i=i+1) begin
			if (in[i] == 1'b1) begin
				tmp[i] = 1'b1;
				valid =  1'b1;
				break;
			end
		end	
	end
end

endgenerate


assign out   = tmp;
assign vld   = valid;

endmodule




module round_robin #(
	parameter NREQ = 4
)(
	input  wire            clk,
	input  wire            rst_n,
	input  wire            clr,			// sync reset rr arbiter
	input  wire [NREQ-1:0] req,
	input  wire            enable,
	output reg  [NREQ-1:0] gnt
	output reg             vld
);


reg [NREQ-1:0] rr_grant;				// rr scheduled grant
reg [NREQ-1:0] mask_grant;				// masked grant
reg [NREQ-1:0] unmask_grant;			// unmasked grant
reg [NREQ-1:0] rr_req;					//
reg [NREQ-1:0] mask_req;
reg [NREQ-1:0] maks_req_prio;
reg [NREQ-1:0] unmask_req_prio;
reg [NREQ-1:0] token;
reg [NREQ-1:0] next_token;
reg            valid;


// when scheduler enabled and there are requests, assert vld
assign vld = ((|req) & enable) ? 1'b1 : 1'b0;


// priority encoded masked requests
genvar i;

generate
for (i=0; i<NREQ; i=i+1) begin: PRIORITY
	if (i == 0) begin: PRIO0
	end else begin: PRIO
		assign mask_req_prio[i] = (|mask_req[i-1:0])
	end
end
endgenerate

// generate masked & unmasked grant signals
assign mask_grant = mask_req & (~mask_req_prio);
assign unmask_grant = rr_req & (~unmask_req_prio);

// choose between masked or unmasked
assign rr_grant   = (mask_req == {{NREQ}{1'b0}} ?  unmask_grant : mask_grant;
assign next_token = (mask_req == {{NREQ}{1'b0}} ?  unmask_req_prio : mask_req_prio;


// token update procedure, only to capture when vld is asserted
always @(posedge clk or negedge rst_n) begin
	if (!rst_n)
		token <= {NREQ{1'b0}};
	else begin
		if (vld)
			token <= next_token;
		else
			token <= token;
	end
end
endmodule


module rr_arbiter #(
    parameter WIDTH = 8,
    parameter DIRECTION = "LSB"
) (
    input wire clk,
    input wire rst_n,
    input wire enable,
    input wire [WIDTH-1:0] reqeust,
    output wire [WIDTH-1:0] grant
);


    wire [WIDTH-1:0] mask, mask_reqeust;
    wire [WIDTH-1:0] mask_onehot, onehot, selection;

    // unfortunately we have to explicitly instantiate registers
    reg [WIDTH-1:0] ff_selection;

    // mask input request
    assign mask_requet = request & mask;

    // instantiate leading one detector(if we want binary output, change
    // priority encoder
    leading_one_detector #(
        .WIDTH(WIDTH),
        .DIRECTION(DIRECTION)
    ) mask_decoder (
        .in(mask_request),
        .out(mask_onehot)
    );
    leading_one_detector #(
        .WIDTH(WIDTH),
        .DIRECTION(DIRECTION)
    ) decoder (
        .in(request),
        .out(onehot)
    );

    // Mux of two detector's output
    assign selection = ( |mask ) ? mask_onehot : onehot;


    generate if(DIRECTION == "LSB") begin: LSB_SEL
        always @(posedge clk or negedge rst_n) begin
            if (!rst_n)
                ff_selection <= {WIDTH{1'b0}};
            else if(enable)
                ff_selection <= selection;
        end
    end else begin: MSB_SEL
        always @(posedge clk or negedge rst_n) begin
            if (!rst_n)
                ff_selection <= {WIDTH{1'b1}};
            else if (enable)
                ff_selection <= selection;
        end
    end endgenerate

    // mask generation
     onehot2thermal #(.WIDTH(WIDTH), .DIRECTION(DIRECTION)) masker (
         .in(selection),
         .out(mask)
     );

    assign grant = ff_selection;

endmodule


module weighted_round_robin #(
	parameter NREQ      = 3,
	parameter THRESHOLD = 8,
	parameter THRW      = `CLOG2(THRESHOLD+1)

) (
    input                           clk,
    input                           rst_n,
	input                           enable,
	// weights threshold
    input       [THRW-1:0]          thrd,	
    input       [NREQ-1:0]          req,
    output wire [NREQ-1:0]          grant
);


reg  [THRW-1:0] cred_cnt       [NREQ-1:0];
wire [THRW-1:0] cred_cnt_next  [NREQ-1:0];
wire [THRW-1:0] cred_cnt_incr  [NREQ-1:0];

wire [NREQ-1:0] has_crd;
wire [NREQ-1:0] mask_req;

wire replenish;

// when none of the asserted requests have credits, replenish all credit counters
assign replenish = ((req & has_crd) == {NREQ{1'b0}});

genvar i;
generate
for (i=0; i<NREQ; i= i+1) begin

	// compute next credit left behind
    assign cred_cnt_incr[i] = cred_cnt[i] + 1'b1;
    assign has_crd[i]       = (cred_cnt_incr[i] <= thrd);

    // credit mask logic generates masked requests
    assign mask_req[i] = (has_crd[i] | replenish) & req[i];

    // next credit counter value
    always @(*) begin
        cred_cnt_next[i] = cred_cnt[i];
        if (replenish)
            if (gnt[i])
                cred_cnt_next[i] = 1;
            else
                cred_cnt_next[i] = 0;
        else if (gnt[i])
            cred_cnt_next[i] = cred_cnt_incr[i];
		else
			cred_cnt_next[i] = cred_cnt[i];
    end

    // only update the credit counters when replenish or being granted
    always @(posedge clk or negedge rst_n) begin
        if (~rst_n)
            cred_cnt[i] <= {THRW{1'b0}};
        else begin
			if (replenish | gnt[i])
				cred_cnt[i] <= cred_cnt_next[i];
			else
				cred_cnt[i] <= cred_cnt[i];
		end
	end
end
endgenerate

// the masked version of requests will be fed into normal round robin arbiter
round_robin #(
	.NREQ    (NREQ    ),
) u_rrb_arb  (
	.clk     (clk     ), 
	.rst_n   (rst_n   ),
	.enable  (enable  ),
	.req     (mask_req), 
	.gnt     (gnt     )
);

endmodule


module age_matrix (
    clk,
    rst_n,
    alloc,
    dealloc,
    mask,
    oldest,
    youngest,
    old_vld,
    yog_vld
);

parameter ENTRIES = 4;

input                clk;
input                rst_n;
input [ENTRIES-1:0]  alloc;
input [ENTRIES-1:0]  dealloc;
input [ENTRIES-1:0]  mask;

output [ENTRIES-1:0] oldest;
output [ENTRIES-1:0] youngest;

output               old_vld;
output               yog_vld;

wire [ENTRIES-1:0]   oldest;
wire [ENTRIES-1:0]   youngest;


reg [ENTRIES-1:0] entries [ENTRIES-1:0];
wire [ENTRIES-1:0] rows [ENTRIES-1:0];
wire [ENTRIES-1:0] cols [ENTRIES-1:0];


always @(posedge clk or negedge rst_n) begin: AGE_MATRIX__DE_ALLOC
    integer r;
    integer c;
    if (!rst_n) begin
		for(r=0; r<ENTRIES; r=r+1) begin
			entries[r] <= 0;
		end
    end
    else begin
        for (r=0; r<4; r=r+1) begin
            for (c=0; c<4; c=c+1) begin
                if ((alloc[r] == 1)) begin
                    if ((c == r))
                        entries[r][c] <= 1;
                    else begin
                        if ((dealloc[c] == 1))
                            entries[r][c] <= 0;
                        else
                            entries[r][c] <= entries[c][c];
                    end
                end else begin
                    if ((dealloc[c] == 1))
                        entries[r][c] <= 0;
                    else
                        entries[r][c] <= entries[r][c];
                end
            end
        end
    end
end

genvar i, j;
generate
for(i=0; i<ENTRIES; i=i+1) begin: row
	for(j=0; j<ENTRIES; j=j+1) begin: col
	    assign rows[i][j] = entries[i][j];
	    assign cols[i][j] = entries[j][i];
	end
end
endgenerate

generate
for(i=0; i<ENTRIES; i=i+1) begin: ohot

	one_hot_check #(.WIDTH(ENTRIES)) rcheck(
		.in(rows[i]),
		.out(oldest[i])
	);

	one_hot_check #(.WIDTH(ENTRIES)) ccheck(
		.in(cols[i]),
		.out(youngest[i])
	);
end
endgenerate


one_hot_check #(.WIDTH(ENTRIES)) old_check(
    .in(oldest),
    .out(old_vld) );

one_hot_check #(.WIDTH(ENTRIES)) yog_check(
    .in(youngest),
    .out(yog_vld) );


endmodule

module queue_entry #(

	parameter WIDTH = 16
	
) (
    input  wire             clk,
    input  wire             rst_n,
		   
    input  wire             wen,
    input  wire [WIDTH-1:0] in,
    input  wire             ren,
    input  wire             invld,            # invalidate an entry
	
    output wire [WIDTH-1:0] out,
    output wire             valid,
    output wire             issue

);

// =============================================
// Entry field
// =============================================

reg                vld;
reg [WIDTH-1:0]    data;
reg                isu;

always @(posedge clk or negedge rst_n) begin
	if (!rst_n)
		vld <= 1'b0;
	else begin
		if(wen and !invld)
			vld <= 1'b1;
		else if(!wen and invld and vld)
			vld <= 1'b0;
		else
			vld <= vld;
	end
end

always @(posedge clk or negedge rst_n) begin
	if (!rst_n)
		data <= 0;
	else begin
        if(wen)
            data <= in;
        else
            data <= data;
	end
end

always @(posedge clk or negedge rst_n) begin
	if (!rst_n)
		isu <= 1'b0;
	else if(invld)
        isu <= 1'b0;
    else begin
        if(ren)
			isu <= 1'b1;
        else
            isu <= isu;
	end
end

// =============================================
// output
// =============================================

assign valid      = vld;
assign out        = data;
assign issue      = isu;


endmodule



module queue #( 
	parameter             NB = `VERSTG,  // number of fifo banks
    parameter             ND = `HORSTG,  // number of entries per bank
    parameter             DW = `DATAWD,  // data width
)  ( 
	input  wire           rst_        ,  // global reset 
    input  wire           clk_put     ,  // clocked sender  : clock for sender domain
    input  wire           req_put     ,  // clocked sender  : request put
    output reg            spaceav     ,  // clocked sender  : space available indicator
    input  wire [DW-1:0]  din         ,  // clocked sender  : data in
    input  wire           clk_get     ,  // clocked receiver: clock for receiver domain
    input  wire           req_get     ,  // clocked receiver: request get
    output reg            datav       ,  // clocked receiver: data valid indicator
    output wire [DW-1:0]  dout           // clocked receiver: data out
); 
	 

// =============================================
// Queue Entries
// =============================================

localparam ENTRIES = NB*ND;

wire [DW-1:0] eout [ENTRIES-1:0];

wire [ENTRIES-1:0] ewen;
wire [ENTRIES-1:0] evld;
wire [ENTRIES-1:0] evld;
wire [ENTRIES-1:0] evld;


genvar i;

generate
for (i=0; i<ENTRIES-1; i=i+1) begin
	queue_entry #(.WIDTH(DW)) entry (
		.clk(clk),
		.rst_n(rst_n),
		.wen(ewen[i]),
		.in(din),
		.ren(eren[i]),
		.invld(einvld[i]),            # invalidate an entry
		.out(eout[i]),
		.valid(evld[i]),
		.issue(eisu[i]) );
		
end
endgenerate

	 
// =============================================
// write allocation
// =============================================

priority_mask #( 
	.WIDTH(NV)
) allocator (
	.in(evld), 
	.dout(ewen), 
	.valid(full)
);


endmodule

