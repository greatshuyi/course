//-----------------------------------------------------------------------------------
// ### Fixed priority arbiter
//
// For fixed prioity aribter with N requests, the grant signals is generated by 
// finding the first asserted requestors starting from the highest priority(e.g. 
// MSB downto LSB or vice versa). For instance, the i-th grant signals out of N 
// requests with LSB priority is formed as follow:
//    gnt[i] = req[i] & (~(|req[i-1:0]));	// gnt[i] = req[i] & (&(~req[i-1:0]));
//
// ### Round robin arbiter
//
//-----------------------------------------------------------------------------------

`include "lib.vh"
`include "dw.v"



module fixed_priority_arbiter #(
	
	parameter NREQ = 4,
	parameter NIDX = `CLOG2(NREQ)
	
) (
	input               clk,
	input               rst_n,
	input               enable,

	input  [NREQ-1:0]   request,
	input  [NREQ-1:0]   mask,
	output [NREQ-1:0]   grant,
	output              valid,
	
	output [NIDX-1:0]   index,
	output [NREQ-1:0]   token				// also served as last grant vector             

);

// Encoded selected index



// register grant as token vector
always @(posedge clk or negedge rst_n) begin
	if (!rst_n)
		token <= {NREQ{1'b0}};
	else begin
		if (enable)
			token <= grant;
		else
			token <= token;
	end
end

endmodule


//-------------------------------------------------------------------------
// Parameterized dynamic priority arbiter
//	1. for priority type arbiter, arbiter does not have repleinish 
//     capability, one can only
//  2. 
//-------------------------------------------------------------------------

module dynamic_priority_aribter #

	parameter NREQ = 4,
	parameter REQW = `CLOG2(NREQ),
	parameter MPRI = NREQ,
	parameter PRIW = `CLOG2(MPRI),
	
) (

	input  wire              clk,
	input  wire              rst_n,
	input  wire              enable,
	
	input  wire [NREQ-1:0]   request,
	input  wire [PRIW-1:0]   priorities [NREQ-1:0];
	input  wire [NREQ-1:0]   mask,
	
	
	output wire [NREQ-1:0]   grant,
	output wire              valid,
	output wire              equal,			// important: indicate all requests have the same priority
	output wire [NIDX-1:0]   index,
	output wire [NREQ-1:0]   token

);

// 1. The maximum priority weight should be equal or less than NREQ
localparam MAX_PRIORITY = ( MPRI >= NREQ ) ? NREG : MPRI;

// priority comparison matrix size
wire [NREQ-1:0] request_matrix [NREQ-1:0];

genvar r, c;

//-----------------------------------------------------------------------------
// 1. mask requests & check if all request are the same 
//    priority level
//-----------------------------------------------------------------------------

wire [NREQ-1:0] mrequest = request & mask & {NREQ{enable}};

wire [NREQ-2:0] euqul_priority;

generate

	for ( r = 0 ; r < NREQ-1 ; r = r + 1) begin: same_checker
		equal_priority[r] = (priorities[r] == priorities[r+1]);
	end

endgenerate

wire 

//-----------------------------------------------------------------------------
// 2. form request matrix based on priorities
//-----------------------------------------------------------------------------

generate
	for (r = 0; r < MPRI; r=r+1) begin: mrow
		for (c = 0; c < NREQ; c=c+1) begin: mcol
			assign request_matrix[r][c] = mrequest[c] & (priorities[c] == r);
		end
	end
endgenerate

wire [NREQ-1:0] priority_level_n;

generate
	for (r = 0; r < NREQ; r = r + 1) begin: level
		assign priority_level_n[r] = ~(|request_matrix[r]);
	end
endgenerate


//-----------------------------------------------------------------------------
// 3. find the highest priority level of requests
//-----------------------------------------------------------------------------
 
wire [NREQ-1:0] priority_selection;

leading_zero_detector #(
	.WIDTH(NREQ)
)
priority_selector
(
	in (priority_level_n) ,
	out(priority_selection),
	vld(priority_valid)
);

wire [NREQ-1:0] priority_request;

vmux #(
	.LANE(MAX_PRIORITY),
	.WIDTH(NREQ)
)
request_selector (
	.in (request_matrix),
	.sel(request_selection),
	.de ({NREQ{1'b0}}),
	.out(prioity_request)
);
 

//-----------------------------------------------------------------------------
// 4. generate prioritized grant from priority_request, LSB first
//-----------------------------------------------------------------------------

wire [NREQ-1:0] priority_grant;
wire            priority_valid;

wire [NREQ-1:0] priority_grant_n = ~priority_request;

leading_zero_detector #(
	.WIDTH(NREQ)
)
priority_granter (
	.in (priority_request_n) ,
	.out(priority_grant),
	.vld(priority_valid)
);


always @(posedge clk or negedge rst_n) begin
	if (!rst_n)
		token <= {NREQ{1'b0}};
	else begin
		if (enable & priority_valid)
			token <= priority_grant;
		else
			token <= token;
	end
end


encode #(
	.IWIDTH(NREQ)
) 
priority_index_encoder (
	.in (priority_grant),
	.out (priority_index),
	.vld ()
);


assign grant = priority_grant & {NREQ{enable}};
assign valid = priority_valid & enable;
assign index = priority_index & {NREQ{enable}};
assign token = priority_token;



endmodule /* dynamic_priority_aribter */





module round_robin_arbiter #(
	
	parameter NREQ = 4,
	parameter NIDX = `CLOG2(NREQ),
	
	// time slots
	parameter SLOTW = 4,
	
) (
	
	input                    clk,
	input                    rst_n,
	input                    enable,
	input				     repleinish,
	input                    arbitrate,			// actively trigger arbitration
	
	// arbitration
	input  wire [NREQ-1:0]   request,
	input  wire [NREQ-1:0]   mask,
	output wire [NREQ-1:0]   grant,
	
	output                   valid,
	output wire [NIDX-1:0]   index
	output reg  [NREQ-1:0]   token;
	
	// slots control
	input  wire              load,
	input  wire [SLOTW-1:0]  amount,
	output reg               depleted			// slots of current round depleted
	
	
	
);

//-----------------------------------------------------------------------------
// arthitectural control
//-----------------------------------------------------------------------------

localparam [] MAX_SLOT = 2**SLOTW-1;

reg  [NREQ-1:0] token;										// grant token
reg  [NREQ-1:0] thermal;									// thermal masked token

// mask incoming requests
wire [NREQ-1:0] mask_request = request & mask;
wire [NREQ-1:0] thermal_requet = request & mask& thermal;	// requests masked by thermal decoded token

wire slot_depleted = (slot == 1);
wire request_desert = ~(|(mask & request & token));

wire [NREQ-1:0] mask_grant;
wire [NREQ-1:0] thermal_grant;
wire            mask_vld;
wire            thermal_vld;

//-----------------------------------------------------------------------------
// slots control
//-----------------------------------------------------------------------------

reg  [SLOTW-1:0] slot;
reg  [SLOTW-1:0] default_slot;


always @(posedge clk or negedge rst_n) begin
	if (!rst_n)
		default_slot <= MAX_SLOT;
	else begin
		if (load_slot)
			default_slot <= (amount < 1) ? 1 : amount;
		else
			default_slot <= default_slot;
	end
end

always @(*) begin
	if (repleinish)
		nxt_slot = (slots[0] < MAX_SLOT) ? MAX_SLOT : slots[0];
	else if (arbitrate | request_desert | slot_depleted)
		nxt_slot = slots 
		
end

always @(posedge clk or negedge rst_n) begin
	if (!rst_n)
		slot <= 1;
	else begin
		if (enable)
			slot <= nxt_slot;
		else
			slot <= slot;
	end
end
	

//-----------------------------------------------------------------------------
// arbitration
//-----------------------------------------------------------------------------

// mux between two fixed priority arbiter to 
// generate valid and grant
leading_zero_detector #(
    .WIDTH(NREQ)
) 
thermal_mask_priority_arbiter (
    .in(thermal_request),
    .out(thermal_grant),
	.vld(thermal_vld)
);
leading_one_detector #(
    .WIDTH(NREQ)
) 
priority_arbiter (
    .in(mask_request),
    .out(mask_grant),
	.vld(mask_vld)
);

assign grant = ( ~(|thermal) ) ? mask_grant : thermal_grant;
assign valid = ( ~(|thermal) ) ? mask_vld & enable : thermal_grant & enable;
assign depleted = slot_depleted;
								   
// token & mask control

// updated token when actively triggered arbitrate or 
// current slots depleted or current requestor deasserted

wire token_enable = enable & (arbitrate | request_desert | slot_depleted);

always @(posedge clk or negedge rst_n) begin
	if (!rst_n)
		token <= 1;
	else if(repleinish)
		token <= 1;
	else begin
		if (token_enable)
			token <= grant;
		else
			token <= token;
	end
end

onehot2thermal #(
    .WIDTH(NREQ),
    .DIRECTION("LSB")
) (
    .in(token),
    .out(thermal)
);

endmodule


module weighted_round_robin_arbiter #(

	parameter NREQ = 4,
	parameter NIDX = `CLOG2(NREQ),
	
	// time slots
	parameter MAX_SLOT = 8,
	parameter SLOTW = `CLOG2(MAX_SLOT),
	
	// weights
	parameter GWEIGHTW = 4,						// global weights
	parameter LWEIGHTW = 4,						// local weights
	
) (
	input               clk,
	input               rst_n,
	input               enable,
	
	
	// arbitration interface
	input  [NREQ-1:0]   request,
	input  [NREQ-1:0]   mask,
	output [NREQ-1:0]   grant,
	output              valid,
	output [NIDX-1:0]   index
	
	// weights interface
	
	
);



//-----------------------------------------------------------------------------
// slots control
//-----------------------------------------------------------------------------
reg [WEIGHTW-1:0] weights [NREQ-1:0];


genvar i;
generate
	for(i=0;  i< NREG; i=i+1) begin: weigth_ctrl
		
		always @(posedge clk or negedge rst_n) begin
			if (!rst_n)
				weights[i] <= 0;
			else begin
				if (load_weight)
					weights[i] <= weight;
				else
			end
		end
	
	end
endgenerate


endmodule



module deficit_wrr_arbiter #(

	parameter NREQ = 4,
	parameter NIDX = `CLOG2(NREQ)
) (

);



endmodule





